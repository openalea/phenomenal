diff --git a/examples/scripts/example_skeletonize_phenomenal.py b/examples/scripts/example_skeletonize_phenomenal.py
index 0f72550..a6a2ffe 100644
--- a/examples/scripts/example_skeletonize_phenomenal.py
+++ b/examples/scripts/example_skeletonize_phenomenal.py
@@ -9,12 +9,19 @@
 #       OpenAlea WebSite : http://openalea.gforge.inria.fr
 #
 # ==============================================================================
-from alinea.phenomenal.data_access import plant_1_voxel_centers
-from alinea.phenomenal.display import (
-    show_voxels)
+from alinea.phenomenal.data_access import plant_1_voxel_point_cloud
+from alinea.phenomenal.display import (vtk_show_voxel_points_cloud,
+                                       vtk_show_voxel_skeleton,
+                                       vtk_show_voxel_maize_segmentation)
 
 from alinea.phenomenal.display.segmentation3d import show_segments
-from alinea.phenomenal.segmentation_3d.skeleton import skeletonize
+
+from alinea.phenomenal.data_structure import (VoxelSkeleton)
+
+from alinea.phenomenal.segmentation_3d import (
+    voxel_graph_from_voxel_point_cloud,
+    skeletonize,
+    labelize_maize_skeleton)
 
 # ==============================================================================
 
@@ -22,26 +29,28 @@ from alinea.phenomenal.segmentation_3d.skeleton import skeletonize
 def main():
 
     voxels_size = 16
+    vpc = plant_1_voxel_point_cloud(voxels_size=voxels_size)
+
+    vtk_show_voxel_points_cloud(vpc)
+
+    voxel_graph = voxel_graph_from_voxel_point_cloud(vpc)
+    voxel_skeleton = skeletonize(voxel_graph.graph,
+                                 voxel_graph.voxels_size,
+                                 ball_radius=50)
+
+    vtk_show_voxel_skeleton(voxel_skeleton)
+
+    filename = 'voxel_skeleton.json'
+    voxel_skeleton.write_to_json(filename)
+    voxel_skeleton = VoxelSkeleton.read_from_json(filename)
+    vtk_show_voxel_skeleton(voxel_skeleton)
+
+    vms = labelize_maize_skeleton(voxel_skeleton, voxel_graph)
+
+    vtk_show_voxel_maize_segmentation(vms)
+
+
 
-    voxels_center = plant_1_voxel_centers(voxel_size=voxels_size)
-
-    show_voxels(voxels_center, voxels_size,
-                   color=(0.1, 0.9, 0.1),
-                   size=(5000, 5000),
-                   azimuth=310,
-                   distance=3000,
-                   elevation=90,
-                   focalpoint=(0, 0, 200))
-
-    segments, graph = skeletonize(voxels_center, voxels_size)
-
-    show_segments(segments, voxels_size,
-                  with_voxels=True,
-                  size=(5000, 5000),
-                  azimuth=310,
-                  distance=3000,
-                  elevation=90,
-                  focalpoint=(0, 0, 200))
 
 
 if __name__ == "__main__":
diff --git a/src/alinea/phenomenal/data_structure/__init__.py b/src/alinea/phenomenal/data_structure/__init__.py
index 81c46d4..d4d88e5 100644
--- a/src/alinea/phenomenal/data_structure/__init__.py
+++ b/src/alinea/phenomenal/data_structure/__init__.py
@@ -50,6 +50,8 @@ from .voxelPointCloud import *
 from .voxelGraph import *
 from .voxelSkeleton import *
 from .imageView import *
+from .voxelOrgan import *
+from .voxelMaize import *
 
 # ==============================================================================
 
diff --git a/src/alinea/phenomenal/data_structure/voxelSegment.py b/src/alinea/phenomenal/data_structure/voxelSegment.py
index a00415d..aa3c5c2 100644
--- a/src/alinea/phenomenal/data_structure/voxelSegment.py
+++ b/src/alinea/phenomenal/data_structure/voxelSegment.py
@@ -15,11 +15,7 @@
 
 class VoxelSegment(object):
 
-    def __init__(self, voxels_position, voxels_size, polylines,
-                 label=None, info=None):
+    def __init__(self, voxels_position, polyline):
 
         self.voxels_position = voxels_position
-        self.voxels_size = voxels_size
-        self.polylines = polylines
-        self.label = label
-        self.info = info
+        self.polyline = polyline
diff --git a/src/alinea/phenomenal/data_structure/voxelSkeleton.py b/src/alinea/phenomenal/data_structure/voxelSkeleton.py
index 02b9ec1..c0c0dc4 100644
--- a/src/alinea/phenomenal/data_structure/voxelSkeleton.py
+++ b/src/alinea/phenomenal/data_structure/voxelSkeleton.py
@@ -21,26 +21,13 @@ from alinea.phenomenal.data_structure import (
 
 class VoxelSkeleton(object):
 
-    def __init__(self, voxel_segments=None):
-        if voxel_segments is None:
-            self.voxel_segments = list()
-        else:
-            self.voxel_segments = voxel_segments
+    def __init__(self, voxels_size, ball_radius):
+        self.voxel_segments = list()
+        self.voxels_size = voxels_size
+        self.ball_radius = ball_radius
 
-    def get_voxels_size(self):
-        if len(self.voxel_segments) > 0:
-            return self.voxel_segments[0].voxels_size
-
-    def add_voxel_segment(self, voxels_position, voxels_size, polylines,
-                          label=None, info=None):
-
-        voxel_segment = VoxelSegment(voxels_position,
-                                     voxels_size,
-                                     polylines,
-                                     label=label,
-                                     info=info)
-
-        self.voxel_segments.append(voxel_segment)
+    def add_voxel_segment(self, voxels_position, polyline):
+        self.voxel_segments.append(VoxelSegment(voxels_position, polyline))
 
     def get_leaf_order(self, number):
         for vs in self.voxel_segments:
@@ -79,7 +66,6 @@ class VoxelSkeleton(object):
                 cornet_leafs.append(vs)
         return cornet_leafs
 
-
     # ==========================================================================
     # READ / WRITE
     # ==========================================================================
@@ -172,11 +158,16 @@ class VoxelSkeleton(object):
 
         with open(filename, 'w') as f:
 
-            data = list()
+            data = dict()
+            data['voxels_size'] = self.voxels_size
+            data['ball_radius'] = self.ball_radius
+
+            data['voxel_segments'] = list()
             for v in self.voxel_segments:
-                d = v.__dict__.copy()
-                d['voxels_position'] = list(d['voxels_position'])
-                data.append(d)
+                d = dict()
+                d['polyline'] = v.polyline
+                d['voxels_position'] = list(v.voxels_position)
+                data['voxel_segments'].append(d)
 
             json.dump(data, f)
 
@@ -186,17 +177,13 @@ class VoxelSkeleton(object):
         with open(filename, 'rb') as f:
             data = json.load(f)
 
-            vpcs = VoxelSkeleton()
+            voxel_skeleton = VoxelSkeleton(data['voxels_size'],
+                                           data['ball_radius'])
 
-            for d in data:
+            for d in data['voxel_segments']:
                 voxels_position = set(map(tuple, d['voxels_position']))
+                polyline = map(tuple, list(d["polyline"]))
+                voxel_skeleton.add_voxel_segment(
+                    voxels_position, polyline)
 
-                polylines = list()
-                for path in d["polylines"]:
-                    polylines.append(map(tuple, list(path)))
-
-                vpcs.add_voxel_segment(
-                    voxels_position, d['voxels_size'], polylines, d['label'],
-                    d['info'])
-
-        return vpcs
+        return voxel_skeleton
diff --git a/src/alinea/phenomenal/display/__init__.py b/src/alinea/phenomenal/display/__init__.py
index 6481304..6c9a2a9 100644
--- a/src/alinea/phenomenal/display/__init__.py
+++ b/src/alinea/phenomenal/display/__init__.py
@@ -98,7 +98,7 @@ from .voxelPointCloud import *
 from .voxels import *
 from .voxelSkeleton import *
 from .colormap import *
-
+from .display_vtk import *
 # ==============================================================================
 
 __all__ = [s for s in dir() if not s.startswith('_')]
diff --git a/src/alinea/phenomenal/display/center_axis.py b/src/alinea/phenomenal/display/center_axis.py
index 5fd49ee..eec64fd 100644
--- a/src/alinea/phenomenal/display/center_axis.py
+++ b/src/alinea/phenomenal/display/center_axis.py
@@ -13,22 +13,28 @@ import mayavi.mlab
 # ==============================================================================
 
 
-def plot_center_axis():
+def plot_center_axis(figure=None):
+
+    if figure is None:
+        figure = mayavi.mlab.gcf()
 
     mayavi.mlab.quiver3d(0, 0, 0,
                          100, 0, 0,
                          line_width=5.0,
                          scale_factor=1,
-                         color=(1, 0, 0))
+                         color=(1, 0, 0),
+                         figure=figure)
 
     mayavi.mlab.quiver3d(0, 0, 0,
                          0, 100, 0,
                          line_width=5.0,
                          scale_factor=1,
-                         color=(0, 1, 0))
+                         color=(0, 1, 0),
+                         figure=figure)
 
     mayavi.mlab.quiver3d(0, 0, 0,
                          0, 0, 100,
                          line_width=5.0,
                          scale_factor=1,
-                         color=(0, 0, 1))
\ No newline at end of file
+                         color=(0, 0, 1),
+                         figure=figure)
\ No newline at end of file
diff --git a/src/alinea/phenomenal/display/mesh.py b/src/alinea/phenomenal/display/mesh.py
index f14dd18..976049e 100644
--- a/src/alinea/phenomenal/display/mesh.py
+++ b/src/alinea/phenomenal/display/mesh.py
@@ -63,6 +63,7 @@ def show_mesh(vertices, faces,
 
 
 def show_poly_data(poly_data, colored=True):
+
     mapper = vtk.vtkPolyDataMapper()
     mapper.SetInputData(poly_data)
 
@@ -93,7 +94,6 @@ def show_poly_data(poly_data, colored=True):
     renderer.SetActiveCamera(camera)
     renderer.ResetCamera()
     renderer.SetBackground(0, 0, 0)
-
     render_window.SetSize(600, 600)
 
     # interact with data
@@ -106,4 +106,4 @@ def show_poly_data(poly_data, colored=True):
     del camera
     del renderer
     del render_window
-    del render_window_interactor
\ No newline at end of file
+    del render_window_interactor
diff --git a/src/alinea/phenomenal/display/voxelSkeleton.py b/src/alinea/phenomenal/display/voxelSkeleton.py
index 6b8c710..100d38e 100644
--- a/src/alinea/phenomenal/display/voxelSkeleton.py
+++ b/src/alinea/phenomenal/display/voxelSkeleton.py
@@ -31,6 +31,7 @@ def show_voxel_skeleton(voxel_skeleton,
                         distance=None,
                         focalpoint=None):
 
+
     mayavi.mlab.figure(figure=figure_name, size=size)
 
     if with_center_axis:
@@ -112,7 +113,10 @@ def show_voxel_skeleton_labeled(voxel_skeleton,
 
 
 
-def plot_voxel_skeleton_labeled_with_info(voxel_skeleton):
+def plot_voxel_skeleton_labeled_with_info(voxel_skeleton, figure=None):
+
+    if figure is None:
+        figure = mayavi.mlab.gcf()
 
     random_color_leaf = random_color_map()
 
@@ -132,20 +136,23 @@ def plot_voxel_skeleton_labeled_with_info(voxel_skeleton):
         else:
             color = color_label[vs.label]
 
-        plot_voxels(vs.voxels_position, vs.voxels_size, color=color)
+        plot_voxels(vs.voxels_position, vs.voxels_size, color=color,
+                    figure=figure)
 
         if ((vs.label == "mature_leaf" or vs.label == "cornet_leaf") and
-                    'length' in vs.info):
+                'length' in vs.info):
             x, y, z = vs.info['position_tip']
 
             mayavi.mlab.points3d(x, y, z, mode="sphere",
                                  color=(1, 0, 0),
-                                 scale_factor=30)
+                                 scale_factor=30,
+                                 figure=figure)
 
             x, y, z = vs.info['position_base']
             mayavi.mlab.points3d(x, y, z, mode="sphere",
                                  color=(0, 0, 1),
-                                 scale_factor=30)
+                                 scale_factor=30,
+                                 figure=figure)
 
             s = ("{length}\n{max_width}\n{mean_width}".format(
                 length=int(vs.info['length']) / 10.0,
@@ -155,7 +162,8 @@ def plot_voxel_skeleton_labeled_with_info(voxel_skeleton):
             xt, yt, zt = vs.info['position_tip']
             mayavi.mlab.text3d(xt, yt, zt, s,
                                scale=30,
-                               color=(0, 0, 1))
+                               color=(0, 0, 1),
+                               figure=figure)
 
             xb, yb, zb = vs.info['position_base']
             xm, ym, zm = vs.info['vector_mean']
@@ -163,7 +171,8 @@ def plot_voxel_skeleton_labeled_with_info(voxel_skeleton):
                                  xm, ym, zm,
                                  line_width=5.0,
                                  scale_factor=1,
-                                 color=(1, 1, 1))
+                                 color=(1, 1, 1),
+                                 figure=figure)
 
         if vs.label == "mature_leaf" and 'vector_mean_one_quarter' in vs.info:
             xb, yb, zb = vs.info['position_base']
@@ -172,7 +181,8 @@ def plot_voxel_skeleton_labeled_with_info(voxel_skeleton):
                                  xm, ym, zm,
                                  line_width=5.0,
                                  scale_factor=2,
-                                 color=(0, 0, 1))
+                                 color=(0, 0, 1),
+                                 figure=figure)
 
 
 def show_voxel_skeleton_labeled_with_info(voxel_skeleton,
@@ -199,6 +209,8 @@ def show_voxel_skeleton_labeled_with_info(voxel_skeleton,
     mayavi.mlab.show()
 
 
+
+
 def screenshot_voxel_skeleton_labeled_with_info(voxel_skeleton,
                                           figure_name="",
                                           size=(800, 700),
diff --git a/src/alinea/phenomenal/display/voxels.py b/src/alinea/phenomenal/display/voxels.py
index 753c8f1..de3f442 100644
--- a/src/alinea/phenomenal/display/voxels.py
+++ b/src/alinea/phenomenal/display/voxels.py
@@ -127,7 +127,11 @@ def screenshot_voxels(voxels_position, voxels_size,
 # ==============================================================================
 # ==============================================================================
 
-def plot_voxels(voxels_position, voxels_size, color=None):
+
+def plot_voxels(voxels_position, voxels_size, color=None, figure=None):
+
+    if figure is None:
+        figure = mayavi.mlab.gcf()
 
     pts = numpy.array(list(voxels_position))
     pts = pts.astype(int)
@@ -141,15 +145,16 @@ def plot_voxels(voxels_position, voxels_size, color=None):
         mayavi.mlab.points3d(pts[:, 0], pts[:, 1], pts[:, 2],
                              mode='cube',
                              color=color,
-                             scale_factor=voxels_size)
+                             scale_factor=voxels_size,
+                             figure=figure)
 
-    del pts
+    # del pts
 
     return color
 
 
 def plot_list_voxels(list_voxels_position, list_voxels_size,
-                     list_color=None):
+                     list_color=None, figure=None):
 
     if list_color is None:
         list_color = [None] * len(list_voxels_position)
@@ -158,7 +163,7 @@ def plot_list_voxels(list_voxels_position, list_voxels_size,
                                                    list_voxels_size,
                                                    list_color):
 
-        plot_voxels(voxels_position, voxels_size, color=color)
+        plot_voxels(voxels_position, voxels_size, color=color, figure=figure)
 
 # ==============================================================================
 # ==============================================================================
diff --git a/src/alinea/phenomenal/segmentation_3d/algorithm.py b/src/alinea/phenomenal/segmentation_3d/algorithm.py
index d82ca8d..2a149e0 100644
--- a/src/alinea/phenomenal/segmentation_3d/algorithm.py
+++ b/src/alinea/phenomenal/segmentation_3d/algorithm.py
@@ -134,20 +134,20 @@ def peak_stem_detection(closest_nodes, leafs):
         distance = get_length_point_cloud(closest_nodes[i])
         distances.append(float(distance))
 
-    values_stem = [1] * len(closest_nodes)
-    for i in range(len(closest_nodes)):
-        for voxels, paths in leafs:
-            v = len(set(closest_nodes[i]).intersection(voxels))
-            values_stem[i] += float(v) / float(len(closest_nodes[i]))
-
-    distances_length = list()
-    for i in range(len(values_stem)):
-        distances_length.append(float(distances[i]) * float(nodes_length[i]))
-
-    mix = list()
-    for i in range(len(values_stem)):
-        mix.append(float(distances[i]) * float(nodes_length[i]) /
-                   float(values_stem[i]))
+    # values_stem = [1] * len(closest_nodes)
+    # for i in range(len(closest_nodes)):
+    #     for voxels, paths in leafs:
+    #         v = len(set(closest_nodes[i]).intersection(voxels))
+    #         values_stem[i] += float(v) / float(len(closest_nodes[i]))
+    #
+    # distances_length = list()
+    # for i in range(len(values_stem)):
+    #     distances_length.append(float(distances[i]) * float(nodes_length[i]))
+    #
+    # mix = list()
+    # for i in range(len(values_stem)):
+    #     mix.append(float(distances[i]) * float(nodes_length[i]) /
+    #                float(values_stem[i]))
 
     # import matplotlib.pyplot
     # from alinea.phenomenal.display.peak import plot_values, show_values
@@ -164,7 +164,8 @@ def peak_stem_detection(closest_nodes, leafs):
     # label_color[2] = 'go'
     # label_color[3] = 'ko'
 
-    stop = mix.index(max(mix))
+    # stop = mix.index(max(mix))
+    stop = nodes_length.index((max(nodes_length)))
 
     def find_stem_min_peak(values):
 
@@ -219,18 +220,18 @@ def peak_stem_detection(closest_nodes, leafs):
 
     min_peaks_stem = find_stem_min_peak(nodes_length)
 
-    # import matplotlib.pyplot
-    # from alinea.phenomenal.display.peak import plot_values
-    # matplotlib.pyplot.figure()
-    # plot_values(nodes_length, 'r', plot_peak=True)
+    import matplotlib.pyplot
+    from alinea.phenomenal.display.peak import plot_values
+    matplotlib.pyplot.figure()
+    plot_values(nodes_length, 'r', plot_peak=True)
     # plot_values(mix, 'm', plot_peak=True)
-    # for index, value in min_peaks_stem:
-    #     matplotlib.pyplot.plot(index, value, 'bo')
-    #
-    # # matplotlib.pyplot.plot(stop, max(mix), 'ko')
-    # matplotlib.pyplot.plot(stop, 0, 'ko')
-    #
-    # matplotlib.pyplot.show()
+    for index, value in min_peaks_stem:
+        matplotlib.pyplot.plot(index, value, 'bo')
+
+    # matplotlib.pyplot.plot(stop, max(mix), 'ko')
+    matplotlib.pyplot.plot(stop, 0, 'ko')
+
+    matplotlib.pyplot.show()
 
     distances = smooth(numpy.array(distances))
 
@@ -256,6 +257,11 @@ def stem_detection(stem_segment_voxel, stem_segment_path, leafs, voxel_size,
     # ==========================================================================
 
     arr_stem_segment_voxel = numpy.array(list(stem_segment_voxel))
+    stem_segment_path = numpy.array(stem_segment_path)
+
+    print arr_stem_segment_voxel
+    print stem_segment_path
+    print voxel_size
 
     closest_nodes_planes = compute_closest_nodes_with_planes(
         arr_stem_segment_voxel,
diff --git a/src/alinea/phenomenal/segmentation_3d/maize.py b/src/alinea/phenomenal/segmentation_3d/maize.py
index f2e4995..80d8eb5 100644
--- a/src/alinea/phenomenal/segmentation_3d/maize.py
+++ b/src/alinea/phenomenal/segmentation_3d/maize.py
@@ -15,7 +15,10 @@ import networkx
 from alinea.phenomenal.segmentation_3d.algorithm import (
     merge, stem_detection)
 
-from alinea.phenomenal.data_structure.voxelSkeleton import VoxelSkeleton
+from alinea.phenomenal.data_structure import (
+    VoxelSkeleton,
+    VoxelOrgan,
+    VoxelMaizeSegmentation)
 
 # ==============================================================================
 
@@ -56,7 +59,7 @@ def get_highest_segment(voxel_segments):
     z_max = float("-inf")
     highest_voxel_segment = None
     for voxel_segment in voxel_segments:
-        z = numpy.max(numpy.array(voxel_segment.polylines[0])[:, 2])
+        z = numpy.max(numpy.array(voxel_segment.polyline)[:, 2])
 
         if z > z_max:
             z_max = z
@@ -76,105 +79,76 @@ def labelize_maize_skeleton(voxel_skeleton, voxel_graph):
     highest_voxel_segment = get_highest_segment(voxel_skeleton.voxel_segments)
 
     stem_segment_voxel = highest_voxel_segment.voxels_position
-    stem_segment_path = highest_voxel_segment.polylines[0]
+    stem_segment_path = highest_voxel_segment.polyline
 
 
     # ==========================================================================
-    # from alinea.phenomenal.display.multi_view_reconstruction import (
-    #     show_list_points_3d)
-    #
-    # show_list_points_3d([all_voxels, all_paths, stem_segment_path],
-    #                     list_color=[(0.1, 0.9, 0.1),
-    #                                 (0.9, 0.1, 0.1),
-    #                                 (0.1, 0.1, 0.9)],
-    #                     list_scale_factor=[voxels_size * 0.25,
-    #                                        voxels_size,
-    #                                        voxels_size],
-    #                     size=(5000, 5000),
-    #                     azimuth=310,
-    #                     distance=2000,
-    #                     elevation=90,
-    #                     focalpoint=(0, 0, -250))
-    #
-    # show_list_points_3d([all_voxels, all_paths,
-    #                      stem_segment_voxel,
-    #                      stem_segment_path],
-    #                     list_color=[(0.1, 0.9, 0.1),
-    #                                 (0.9, 0.1, 0.1),
-    #                                 (0.1, 0.1, 0.9),
-    #                                 (0.1, 0.1, 0.9)],
-    #                     list_scale_factor=[voxels_size * 0.25,
-    #                                        voxels_size,
-    #                                        voxels_size * 0.25,
-    #                                        voxels_size],
-    #                     size=(5000, 5000),
-    #                     azimuth=310,
-    #                     distance=2000,
-    #                     elevation=90,
-    #                     focalpoint=(0, 0, -250))
-
-    # ==========================================================================
-    # Fusion little segment close to the stem to the stem
+    from alinea.phenomenal.display import (
+        show_list_voxels)
 
-    tmp_segments = list()
-    for voxel_segment in voxel_skeleton.voxel_segments:
-
-        voxels_position = voxel_segment.voxels_position
-        polyline = voxel_segment.polylines[0]
-        voxels_size = voxel_segment.voxels_size
-
-        supposed_leaf_voxels = voxels_position - stem_segment_voxel
-
-        leaf_path = set(polyline).intersection(supposed_leaf_voxels)
-
-        if len(leaf_path) == 0:
-            stem_segment_voxel = stem_segment_voxel.union(supposed_leaf_voxels)
-        else:
-
-            leaf_voxel = None
-            subgraph = graph.subgraph(voxels_position)
-
-            i = -1
-            while leaf_voxel is None:
-                for voxels_group in networkx.connected_components(subgraph):
-                    if polyline[i] in voxels_group:
-                        leaf_voxel = voxels_group
-                i -= 1
-
-            neighbors = get_neighbors(graph, leaf_voxel)
-            stem_neighbors = neighbors.intersection(stem_segment_voxel)
-            tmp_segments.append((leaf_voxel, polyline, stem_neighbors))
+    show_list_voxels([stem_segment_voxel, stem_segment_path], [8, 8])
 
     # ==========================================================================
-    # Fusion segments if is have at least 1 voxels stem neighbors in common
-    tmp_leafs = list()
-    while tmp_segments:
-        segment_voxel, segment_path, stem_neighbors = tmp_segments.pop()
-
-        paths = [segment_path]
-
-        again = True
-        while again:
-            again = False
-            for i, (segment_voxel_2, segment_path_2, stem_neighbors_2) in \
-                    enumerate(tmp_segments):
-
-                if (stem_neighbors.intersection(stem_neighbors_2) and
-                        segment_voxel.intersection(segment_voxel_2)):
-                    segment_voxel = segment_voxel.union(segment_voxel_2)
-                    stem_neighbors = stem_neighbors.union(stem_neighbors_2)
-                    paths.append(segment_path_2)
-                    tmp_segments.pop(i)
-                    again = True
-                    break
+    # Fusion little segment close to the stem to the stem
 
-        tmp_leafs.append((segment_voxel, paths))
+    # tmp_segments = list()
+    # for voxel_segment in voxel_skeleton.voxel_segments:
+    #
+    #     voxels_position = voxel_segment.voxels_position
+    #     polyline = voxel_segment.polyline
+    #
+    #     supposed_leaf_voxels = voxels_position - stem_segment_voxel
+    #
+    #     leaf_path = set(polyline).intersection(supposed_leaf_voxels)
+    #
+    #     if len(leaf_path) == 0:
+    #         stem_segment_voxel = stem_segment_voxel.union(supposed_leaf_voxels)
+    #     else:
+    #
+    #         leaf_voxel = None
+    #         subgraph = graph.subgraph(voxels_position)
+    #
+    #         i = -1
+    #         while leaf_voxel is None:
+    #             for voxels_group in networkx.connected_components(subgraph):
+    #                 if polyline[i] in voxels_group:
+    #                     leaf_voxel = voxels_group
+    #             i -= 1
+    #
+    #         neighbors = get_neighbors(graph, leaf_voxel)
+    #         stem_neighbors = neighbors.intersection(stem_segment_voxel)
+    #         tmp_segments.append((leaf_voxel, polyline, stem_neighbors))
+    #
+    # # ==========================================================================
+    # # Fusion segments if is have at least 1 voxels stem neighbors in common
+    # tmp_leafs = list()
+    # while tmp_segments:
+    #     segment_voxel, segment_path, stem_neighbors = tmp_segments.pop()
+    #
+    #     paths = [segment_path]
+    #
+    #     again = True
+    #     while again:
+    #         again = False
+    #         for i, (segment_voxel_2, segment_path_2, stem_neighbors_2) in \
+    #                 enumerate(tmp_segments):
+    #
+    #             if (stem_neighbors.intersection(stem_neighbors_2) and
+    #                     segment_voxel.intersection(segment_voxel_2)):
+    #                 segment_voxel = segment_voxel.union(segment_voxel_2)
+    #                 stem_neighbors = stem_neighbors.union(stem_neighbors_2)
+    #                 paths.append(segment_path_2)
+    #                 tmp_segments.pop(i)
+    #                 again = True
+    #                 break
+    #
+    #     tmp_leafs.append((segment_voxel, paths))
 
     # ==========================================================================
     # Compute Stem detection
 
     stem_voxel, not_stem_voxel, stem_path, stem_top = stem_detection(
-        stem_segment_voxel, stem_segment_path, tmp_leafs, voxels_size)
+        stem_segment_voxel, stem_segment_path, None, voxels_size)
 
     # stem_voxel, stem_neighbors, connected_components = merge(
     #     graph, stem_voxel, not_stem_voxel, percentage=50)
@@ -206,125 +180,128 @@ def labelize_maize_skeleton(voxel_skeleton, voxel_graph):
     stem_top_neighbors = stem_top_neighbors - stem_without_top_neighbors
 
     # ==========================================================================
-    # Remove
+    # Remove stem voxel from voxel segments
 
-    real_leaf = list()
-    for voxel_segment in voxel_skeleton.voxel_segments:
-
-        voxels_position = voxel_segment.voxels_position
-        polylines = voxel_segment.polylines
-        voxels_size = voxel_segment.voxels_size
+    for vs in voxel_skeleton.voxel_segments:
 
         leaf_voxel = None
-        subgraph = graph.subgraph(voxels_position - stem_voxel)
+        subgraph = graph.subgraph(vs.voxels_position - stem_voxel)
         for voxel_group in networkx.connected_components(subgraph):
-            if polylines[0][-1] in voxel_group:
+            if vs.polyline[-1] in voxel_group:
                 leaf_voxel = voxel_group
 
-        if leaf_voxel is not None:
-            real_leaf.append((leaf_voxel, polylines))
+        vs.leaf_voxel = leaf_voxel
 
     # ==========================================================================
-    # Merge voxels
+    # Merge remains voxels of the not stem
 
-    for voxels_position, polylines in real_leaf:
-        not_stem_voxel -= voxels_position
+    for vs in voxel_skeleton.voxel_segments:
+        not_stem_voxel -= vs.leaf_voxel
 
     stem_voxel, stem_neighbors, connected_components = merge(
         graph, stem_voxel, not_stem_voxel, percentage=50)
 
-    for i, (leaf, paths) in enumerate(real_leaf):
-        l, _, connected_components = merge(
-            graph, leaf, set().union(*connected_components), percentage=50)
-
-        real_leaf[i] = (l, paths)
+    for vs in voxel_skeleton.voxel_segments:
+        vs.leaf_voxel, _, connected_components = merge(
+            graph, vs.leaf_voxel, set().union(*connected_components),
+            percentage=50)
 
     voxels_remain = set().union(*connected_components)
     # ==========================================================================
-    leaf_mature, leaf_cornet = list(), list()
-
-    for leaf, polylines in real_leaf:
-        if len(stem_top_neighbors.intersection(leaf)) > 0:
-            leaf_cornet.append((leaf, polylines))
+    # Define mature & cornet leaf
+
+    mature_organs = list()
+    cornet_organs = list()
+    for vs in voxel_skeleton.voxel_segments:
+        if len(stem_top_neighbors.intersection(vs.leaf_voxel)) > 0:
+            vo = VoxelOrgan("cornet_leaf")
+            vo.voxel_segments.append(vs)
+            cornet_organs.append(vo)
         else:
-            leaf_mature.append((leaf, polylines))
+            vo = VoxelOrgan("mature_leaf")
+            vo.voxel_segments.append(vs)
+            mature_organs.append(vo)
 
     # ==========================================================================
-    new_segments = list()
-    for voxels_position, polylines in leaf_mature:
-        neighbors = get_neighbors(graph, voxels_position)
-        stem_neighbors = neighbors.intersection(stem_segment_voxel)
-        new_segments.append((voxels_position, polylines, stem_neighbors))
+    # MERGE LEAF MATURE
+    # ==========================================================================
 
     percentage = 50
-    leafs = list()
-    while new_segments:
-        segment_voxel, polylines, stem_neighbors = new_segments.pop()
+    ltmp = list()
+    while mature_organs:
+
+        vo_1 = mature_organs.pop()
+        voxels_1 = vo_1.voxels_position()
 
         again = True
         while again:
             again = False
-            for i, (segment_voxel_2, polylines_2, stem_neighbors_2) in \
-                    enumerate(new_segments):
+            for i, vo_2 in enumerate(mature_organs):
+                voxels_2 = vo_2.voxels_position()
 
-                nb = len(segment_voxel.intersection(segment_voxel_2))
+                nb = len(voxels_1.intersection(voxels_2))
 
-                if (stem_neighbors.intersection(stem_neighbors_2) and (
-                        (nb * 100 / len(segment_voxel) >= percentage) or
-                        (nb * 100 / len(segment_voxel_2) >= percentage))):
+                if ((nb * 100 / len(voxels_1) >= percentage) or
+                    (nb * 100 / len(voxels_2) >= percentage)):
 
-                    segment_voxel = segment_voxel.union(segment_voxel_2)
-                    stem_neighbors = stem_neighbors.union(stem_neighbors_2)
-                    polylines += polylines_2
-                    new_segments.pop(i)
+                    vo_1.voxel_segments += vo_2.voxel_segments
+
+                    mature_organs.pop(i)
                     again = True
                     break
 
-        leafs.append((segment_voxel, polylines))
+        ltmp.append(vo_1)
 
-    leaf_mature = leafs
+    mature_organs = ltmp
     # ==========================================================================
+    # MERGE LEAF CORNET
     # ==========================================================================
-    new_segments = list()
-    for voxels_position, polylines in leaf_cornet:
-        new_segments.append((voxels_position, polylines))
-
     percentage = 85
-    leafs = list()
-    while new_segments:
-        segment_voxel, polylines = new_segments.pop()
+    ltmp = list()
+    while cornet_organs:
+
+        vo_1 = cornet_organs.pop()
+        voxels_1 = vo_1.voxels_position()
 
         again = True
         while again:
             again = False
-            for i, (segment_voxel_2, polylines_2) in enumerate(new_segments):
+            for i, vo_2 in enumerate(cornet_organs):
+                voxels_2 = vo_2.voxels_position()
+
+                nb = len(voxels_1.intersection(voxels_2))
 
-                nb = len(segment_voxel.intersection(segment_voxel_2))
+                if ((nb * 100 / len(voxels_1) >= percentage) or
+                    (nb * 100 / len(voxels_2) >= percentage)):
 
-                if ((nb * 100 / len(segment_voxel) >= percentage) or
-                    (nb * 100 / len(segment_voxel_2) >= percentage)):
+                    vo_1.voxel_segments += vo_2.voxel_segments
 
-                    segment_voxel = segment_voxel.union(segment_voxel_2)
-                    polylines += polylines_2
-                    new_segments.pop(i)
+                    cornet_organs.pop(i)
                     again = True
                     break
 
-        leafs.append((segment_voxel, polylines))
+        ltmp.append(vo_1)
+
+    cornet_organs = ltmp
 
-    leaf_cornet = leafs
     # ==========================================================================
 
-    vss = VoxelSkeleton()
-    vss.add_voxel_segment(voxels_remain, voxels_size, list(), "unknown")
-    vss.add_voxel_segment(stem_voxel, voxels_size, [stem_path], "stem")
+    vms = VoxelMaizeSegmentation(voxels_size)
+
+    organ_unknown = VoxelOrgan("unknown")
+    organ_unknown.add_voxel_segment(voxels_remain, list())
+    vms.voxel_organs.append(organ_unknown)
 
-    for leaf, polylines in leaf_cornet:
-        vss.add_voxel_segment(leaf, voxels_size, polylines, "cornet_leaf")
+    organ_stem = VoxelOrgan("stem")
+    organ_stem.add_voxel_segment(stem_voxel, stem_path)
+    vms.voxel_organs.append(organ_stem)
 
-    for leaf, polylines in leaf_mature:
-        vss.add_voxel_segment(leaf, voxels_size, polylines, "mature_leaf")
+    # for leaf_organ in cornet_organs:
+    #     vms.voxel_organs.append(leaf_organ)
+    #
+    # for leaf_organ in mature_organs:
+    #     vms.voxel_organs.append(leaf_organ)
 
     # ==========================================================================
 
-    return vss
+    return vms
diff --git a/src/alinea/phenomenal/segmentation_3d/plane_interception.py b/src/alinea/phenomenal/segmentation_3d/plane_interception.py
index 544b93f..39135ed 100644
--- a/src/alinea/phenomenal/segmentation_3d/plane_interception.py
+++ b/src/alinea/phenomenal/segmentation_3d/plane_interception.py
@@ -108,6 +108,8 @@ def compute_closest_nodes_with_planes(voxels, path, radius=8, dist=0.75,
 
         vector_mean = numpy.array(vectors).mean(axis=0)
 
+        print vector_mean
+
         k = vector_mean
 
         # ======================================================================
@@ -124,18 +126,19 @@ def compute_closest_nodes_with_planes(voxels, path, radius=8, dist=0.75,
                                          graph=graph,
                                          radius_dist=radius_dist,
                                          without_connexity=without_connexity)
+
         closest_nodes.append(nodes)
 
     return closest_nodes
 
 
-def compute_closest_nodes_with_ball(voxels, path, radius=50, graph=None):
+def compute_closest_nodes_with_ball(voxels, path, ball_radius=50, graph=None):
 
     closest_nodes = list()
     path = numpy.array(path)
     for i, node in enumerate(path):
         res = numpy.linalg.norm(voxels - node, axis=1)
-        index = numpy.where(res < radius)
+        index = numpy.where(res < ball_radius)
         nodes = voxels[index]
 
         if graph is not None:
diff --git a/src/alinea/phenomenal/segmentation_3d/plant_analysis.py b/src/alinea/phenomenal/segmentation_3d/plant_analysis.py
index 4f40b13..5d3a249 100644
--- a/src/alinea/phenomenal/segmentation_3d/plant_analysis.py
+++ b/src/alinea/phenomenal/segmentation_3d/plant_analysis.py
@@ -549,6 +549,21 @@ def maize_cornet_leaf_analysis(cornet_leaf_voxel_segment,
     return info
 
 
+def maize_order_leaf(voxel_skeleton_labeled):
+
+    l = list()
+    for seg in voxel_skeleton_labeled.voxel_segments:
+        if seg.info is not None and "z_intersection" in seg.info:
+            l.append((seg.info, seg.info["z_intersection"]))
+
+    l.sort(key=lambda x: x[1])
+
+    for i, (info, z) in enumerate(l):
+        info["order"] = i
+
+    return voxel_skeleton_labeled
+
+
 def maize_analysis(voxel_skeleton_labeled, distance_plane=0.5):
 
 
@@ -614,19 +629,6 @@ def maize_analysis(voxel_skeleton_labeled, distance_plane=0.5):
     for vs in voxel_skeleton_labeled.voxel_segments:
         vs.info['label'] = vs.label
 
-    return voxel_skeleton_labeled
-
-
-def maize_order_leaf(voxel_skeleton_labeled):
+    voxel_skeleton_labeled = maize_order_leaf(voxel_skeleton_labeled)
 
-    l = list()
-    for seg in voxel_skeleton_labeled.voxel_segments:
-        if seg.info is not None and "z_intersection" in seg.info:
-            l.append((seg.info, seg.info["z_intersection"]))
-
-    l.sort(key=lambda x: x[1])
-
-    for i, (info, z) in enumerate(l):
-        info["order"] = i
-
-    return voxel_skeleton_labeled
\ No newline at end of file
+    return voxel_skeleton_labeled
diff --git a/src/alinea/phenomenal/segmentation_3d/skeleton.py b/src/alinea/phenomenal/segmentation_3d/skeleton.py
index 37cc2a6..cfc6887 100644
--- a/src/alinea/phenomenal/segmentation_3d/skeleton.py
+++ b/src/alinea/phenomenal/segmentation_3d/skeleton.py
@@ -70,8 +70,7 @@ def segment_path(voxels,
                  array_voxels,
                  skeleton_path,
                  graph,
-                 radius=50,
-                 distance_plane=0.75):
+                 ball_radius=50):
 
     # ==========================================================================
     # Get the longest shorted path of voxels
@@ -99,7 +98,7 @@ def segment_path(voxels,
         closest_nodes = compute_closest_nodes_with_ball(
             array_voxels,
             leaf_skeleton_path,
-            radius=radius,
+            ball_radius=ball_radius,
             graph=graph)
 
         leaf = set().union(*closest_nodes)
@@ -128,7 +127,7 @@ def compute_all_shorted_path(graph, voxels_size):
     return all_shorted_path_to_stem_base
 
 
-def skeletonize(graph, voxels_size, distance_plane=1, radius=50):
+def skeletonize(graph, voxels_size, ball_radius=50):
 
     all_shorted_path_to_stem_base = compute_all_shorted_path(graph, voxels_size)
 
@@ -137,7 +136,7 @@ def skeletonize(graph, voxels_size, distance_plane=1, radius=50):
     np_arr_all_graph_voxels_plant = numpy.array(graph.nodes())
     # ==========================================================================
 
-    voxel_segments = list()
+    voxel_skeleton = VoxelSkeleton(voxels_size, ball_radius)
     while len(voxels_position_remain) != 0:
 
         (voxels_position_segment,
@@ -147,16 +146,10 @@ def skeletonize(graph, voxels_size, distance_plane=1, radius=50):
             np_arr_all_graph_voxels_plant,
             all_shorted_path_to_stem_base,
             graph,
-            radius=radius,
-            distance_plane=distance_plane * voxels_size)
+            ball_radius=ball_radius)
 
-        voxel_segment = VoxelSegment(voxels_position_segment,
-                                     voxels_size,
-                                     [voxels_segments_polyline])
-
-        voxel_segments.append(voxel_segment)
-
-    voxel_skeleton = VoxelSkeleton(voxel_segments)
+        voxel_skeleton.add_voxel_segment(voxels_position_segment,
+                                         voxels_segments_polyline)
 
     return voxel_skeleton
 
